---
title: Snippets
description: Copy-pasteable solutions to common problems using ReArch.
---

# Snippets
A collection of copy-pasteable solutions to common development problems, ReArch style.
Everything shown here is _one way_ to solve the corresponding problem;
there are likely other equally-valid solutions as well.

If you have any suggestions of snippets to add,
please open a new issue [here](https://github.com/GregoryConrad/rearch-docs/issues)!


## Sign In Flow
And how to relay the state of an asynchronous action in the UI while it occurs via "mutations."
```dart
/// Provides a [Random].
// NOTE: encapsulating this enables easy implementation switching later on.
final Capsule<Random> randomCapsule = capsule((use) => Random());

/// Provides a function that signs the user in.
final Capsule<Future<void> Function(String, String)> signInAction = capsule((use) {
  // NOTE: we have this `use` call up top (before it is actually needed)
  // because you must never use a CapsuleHandle across an asynchronous gap
  // (which includes in a function callback (below) or after an await).
  // But don't worry, ReArch will give you a reminder if you ever forget.
  final random = use(randomCapsule);

  return (email, password) {
    // Dummy implementation that is fallible
    return Future.delayed(const Duration(seconds: 1), () {
      if (random.nextBool()) throw Exception('Sign in failed');
    });
  };
});

class SignInForm extends RearchConsumer {
  const SignInForm({super.key});

  Widget build(BuildContext context, WidgetHandle use) {
    final (email, setEmail) = use.state('');
    final (password, setPassword) = use.state('');

    final (state: signInState, mutate: mutateSignIn, clear: _) =
        use.mutation<void>();
    final rawSignIn = use(signInAction);
    void signIn() => mutateSignIn(rawSignIn(email, password));

    return Column(
      children: [
        TextField(onChanged: setEmail),
        TextField(onChanged: setPassword),
        ElevatedButton.icon(
          icon: const Icon(Icons.person_rounded),
          onPressed: signInState is AsyncLoading ? null : signIn,
          label: const Text('Sign In'),
        ),
        switch (signInState) {
          null => const SizedBox.shrink(), // no sign-in attempted yet
          AsyncData<void>() => const Text('Signed In'),
          AsyncLoading<void>() => const CircularProgressIndicator(),
          AsyncError<void>(:final error) => Text('$error'),
        },
      ],
    );
  }
}
```


## Testing/Mocks
For a full example, mocking a REST API, see the example
[weather app](https://github.com/GregoryConrad/rearch-dart/blob/main/examples/weather_app/test/basic_test.dart).

```dart title="Mocking capsules in Dart tests"
// I often create useFooBar() methods for disposable resources in my Dart/Flutter tests.
// They compose very similarly to regular side effects.
MockableContainer useContainer() {
  final container = MockableContainer();
  addTearDown(container.dispose);
  return container;
}

(MockableContainer, MockClient) useMockedClientContainer() {
  final mockClient = MockClient();
  final container = useContainer()
    ..mock(httpClientCapsule).apply((use) => mockClient);
  return (container, mockClient);
}

/// Mocked [http.Client] using `mocktail`
class MockClient extends Mock implements http.Client {}

void main() {
  test('fetchWeatherAction returns correct Weather', () async {
    final (container, mockClient) = useMockedClientContainer();

    const latitude = 123.0;
    const longitude = 321.0;
    const temperature = 20.0;
    const weatherCode = 1.0; // = cloudy
    Future<http.Response> expectedCall() => mockClient.get(
          Uri.https('api.open-meteo.com', '/v1/forecast', {
            'latitude': '$latitude',
            'longitude': '$longitude',
            'current_weather': 'true',
          }),
        );
    when(expectedCall).thenAnswer(
      (_) async => http.Response(
        jsonEncode({
          'current_weather': {
            'temperature': temperature,
            'weathercode': weatherCode,
          },
        }),
        200,
      ),
    );

    // fetchWeatherAction will use the `MockClient` we mocked above
    final actualWeather = await container.read(fetchWeatherAction)(
      latitude: latitude,
      longitude: longitude,
    );
    verify(expectedCall).called(1);
    expect(
      actualWeather,
      const Weather(temperature: temperature, weatherCode: weatherCode),
    );
  });
}
```
