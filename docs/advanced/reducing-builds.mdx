---
title: Reducing Builds
description: Learn how to manually reduce rebuilds to improve performance in rearch.
---

# Reducing Builds
Reducing builds is a useful optimization that can be done in rearch through:
1. Conditionally using capsules
2. Inline capsules


## When Do You Need to Reduce Rebuilds?
Consider the following capsule.

<CodeGroup title="Capsule with excessive rebuilds">
  ```dart
  FooBar expensiveOperationUsingCount(CapsuleHandle use) {
    final count = use(countCapsule);
    final isWatching = use(isWatchingCapsule);
    return someExpensiveOperation(isWatching ? count : null);
  }
  ```

  ```rust
  fn expensive_operation_using_count(CapsuleHandle { mut get, .. }: CapsuleHandle) -> FooBar {
    let count = get(count);
    let is_watching = get(is_watching);
    return some_expensive_operation(if is_watching { Some(count) } else { None });
  }
  ```
</CodeGroup>

This looks ok until you realize that whenever `count` changes,
`someExpensiveOperation`/`some_expensive_operation` will be called again,
even if `isWatching`/`is_watching` is false!
These extra rebuilds can be removed with the following.

<CodeGroup title="Limiting extra rebuilds">
  ```dart
  FooBar expensiveOperationUsingCount(CapsuleHandle use) {
    if (use(isWatchingCapsule)) {
      // Having this use within a branch will stop rebuilds caused by
      // countCapsule when isWatching is false.
      return someExpensiveOperation(use(countCapsule));
    }
    return someExpensiveOperation(null);
  }
  ```

  ```rust
  fn expensive_operation_using_count(CapsuleHandle { mut get, .. }: CapsuleHandle) -> FooBar {
    if get(is_watching) {
      // Having this get within a branch will stop rebuilds caused by
      // count when is_watching is false.
      some_expensive_operation(Some(get(count)))
    } else {
      some_expensive_operation(None)
    }
  }
  ```
</CodeGroup>

However, this simple conditional watching is not always enough to reduce some builds;
sometimes, `someExpensiveOperation` is a `Widget` rebuild in Flutter,
where the rebuild depends upon some non-encapsulable data (such as a key in a large collection).
For situations like this, you likely need *inline capsules*
to prevent rebuilding potentially thousands of Widgets displaying the current data in a collection
whenever just a single entry is modified.


## Inline Capsules
Inline capsules are just regular capsules (which, as a reminder, are just functions),
but are unique because they are *closures*.

<Info>
  While you can *define* inline capsules in Rust, they are largely useless at the moment,
  because Rust does not (yet) support negative trait implementations
  (which are needed in order to support these build optimizations).
  Thus, the rest of this page only applies to Dart at the moment.

  To give some context to the problem, capsules are not forced to be `PartialEq`,
  but when a capsule happens to be `PartialEq`,
  we want to skip rebuilding dependents when `newData == oldData`.
  I have not yet found a way to do this without negative trait implementations,
  but if you have an idea, please open a PR!
  It might be possible via trait upcasting, but I haven't looked into it enough to know for sure.
</Info>

There are two ways to create inline capsules:
- `myCapsule.map()`, a convenience extension method that creates an inline capsule
- Manually (but caution must be used here)!

Each solves slightly different use-cases.
However, when possible, it is best to make new *intermediary* top-level capsules instead,
and let rearch use its own optimizations to limit rebuilds.
Remember, capsules are cheap, and are designed to be composed.
You should only very rarely use inline capsules,
and when you do, make sure they are *very cheap* (ideally just a constant-time look-up).


### `.map()`
The example Flutter app utilizes `.map()` to reduce some rebuilds,
so see that for a more full example.
However, here is a simple example to give you an idea of how `.map()` works.

```dart title="Inline capsule example with .map()"
@rearchWidget
Widget myListItem({
  int listIndex,
  WidgetHandle use,
}) {
  // With this inline capsule, we only rebuild when the data at
  // myList[listIndex] changes, instead of the whole myList.
  final dataAtIndex = use(
    // This creates a new inline capsule that gets a particular index of myList:
    myListCapsule.map((myList) => myList[listIndex]),
  );
  return Text('$dataAtIndex');
}
```


### Manual Inline Capsules
Contrary to the `.map()` convenience method, manual inline capsules define the closure explicitly.
This is beneficial when your inline capsule depends on >1 other capsules,
which should be rather rare.

<Warning>
  Only use manual inline capsules when your inline capsule needs to `use`
  *multiple* different capsules,
  as manual inline capsules are easier to mess up and cause leaks!
</Warning>

Here's the previous example, but rewritten to use a manually defined inline capsule.
```dart title="Manual inline capsule example"
@rearchWidget
Widget myListItem({
  int listIndex,
  WidgetHandle use,
}) {
  // With this inline capsule, we only rebuild when the data at
  // myList[listIndex] changes, instead of the whole myList.
  final dataAtIndex = use(
    // This creates a new inline capsule that gets a particular index of myList:
    (CapsuleReader use) => use(myListCapsule)[listIndex],

    // While the following works, it is considered a bad practice
	// (keep reading for an explanation):
    // (use) => use(myListCapsule)[listIndex],
  );
  return Text('$dataAtIndex');
}
```

Notice above how the parameter is declared as `CapsuleReader use`;
while you actually get a full `CapsuleHandle` here for the inline capsule,
you must be careful to not use any side effects (`use.fooBar()`) or *you will cause leaks*.
Thus, it is considered to be a best practice to prevent yourself from using side effects
by declaring the parameter type as `CapsuleReader` instead of letting it get inferred
as a `CapsuleHandle` (which is what happens if you do not explicitly specify `CapsuleReader`).
